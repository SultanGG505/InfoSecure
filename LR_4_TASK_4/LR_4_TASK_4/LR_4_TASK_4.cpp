
#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>
#include <string>
//
//4 Множители.Основная теорема арифметики утверждает, что каждое
//целое число, большее 1, может быть однозначно представлено как
//произведение
//одного
//или
//нескольких
//простых
//чисел.
//При
//уникальном наборе простых множителей возможно несколько их
//упорядочений.Например, 10 = 2 * 5, 10 = 5 * 2. 20 = 2 * 2 * 5, 20 = 2 * 5 * 2,
//20 = 5 * 2 * 2. Пусть() будет числом различных расположений
//простых множителей натурального числа.Так что(10) = 2,
//(20) = 3 Дано натуральное число, всегда существует по крайней
//мере одно такое натуральное, для которого() = .Требуется
//вычислить по заданному такое наименьшее число .
//Входные данные берутся из файла naturals.in.Файл содержит какое -
//то количество произвольных натуральных чисел из диапазона 2 . 263
//В одной строке содержится ровно одно число.Выходные данные
//помещаются в файл naturals.out.В каждой строке находится два
//числа : число из входного файла и соответствующее ему значение,
//такое, что() = .
//1 2
//2 6
//3 12
//105 720

using namespace std;

vector<int> factorize(int x) {   // vector<int> // метод для факторизации, т.е для разложения числа на множители
    vector<int> factors;

    for (int i = 2; i <= sqrt(x); i++) {
        while (x % i == 0) {
            factors.push_back(i);
            x /= i;
        }
    }
    if (x != 1) {
        factors.push_back(x);
    }
    return factors; // можно также вернуть сами множители
}

int factorial(int i)
{
    if (i == 0) return 1;
    else return i * factorial(i - 1);
}
/// <summary>
/// функция для подсчёта кол-ва перестановок множителей из факторизации числа
/// то есть, подсчёт ввида 2*3 и 3*2 = 2шт
/// вначале сортируется вектор(для удобства),
/// затем  объявляется переменная для числителя в формуле подсчёта перестановок
///  затем объвляется массив степеней(например, из факторизации 2 * 2 *2 в массив степеней будет записано число 3(2^3)
/// Важно сказать, что уникальное число например 5 будет записано в массив степеней как 1(то есть 5 * _ -> 1)
/// затем мы рассматриваем два варианта
/// 1) если число num не встречается в факторизации, то мы увеличиваем значения num для его дальнейшего поиска
/// 2) если число num встречается, то мы считаем сколько раз оно встречается и записываем это число в index(чтобы удалить все повторяющиеся числа, после подсчёта их кол-ва)
/// продолжая 2) случай мы задаём указатели на начало и конец вектора и после подсчёта кол-во повторений записываем это как степень(тройка повторилась 2 раза - степень 2)
/// далее мы от начала удаляем index элементов(мы можем так сделать, т.к у нас отсортированный вектор и ошибки не произойдёт
/// затем мы используем формулу перестановок, сначала просчитав числель, а затем поделив его на множители в знаменателе
/// в итоге result мы ВОЗВРАЩАЕМ кол-во упорядочиваний для простых множителей числа
/// </summary>
/// <param name="factos"></param>
/// <returns></returns>
int permut(vector<int> factos) 
{
    sort(factos.begin(), factos.end());
    int high_fact = factos.size();
    vector <int> step;
    int index = 0;
    int num = 0;
    while (!factos.empty())
    {
        if (count(factos.begin(), factos.end(), num) == 0)
        {
            num++;
            continue;
        }
        if (count(factos.begin(), factos.end(), num) != 0)
        {
            auto begin = factos.cbegin(); // указатель на первый элемент
            auto end = factos.cend();     // указатель на последний элемент
            //numbers2.erase(begin + 2, end - 1); // удаляем с третьего элемента до последнего
            // numbers2 = {1, 2, 6}
            
            index = count(factos.begin(), factos.end(), num);
            step.push_back(index);
            /*num++;*/
            factos.erase(begin , begin + index);
        }
    }
    int result = factorial(high_fact);

    for (int i = 0; i < step.size(); i++)
    {
        result /= factorial(step[i]);
    }
    /*cout << result << endl;*/
    return result;
}

int main()
{
    // стандартное чтение файла
    setlocale(LC_ALL, "RUS");
    vector <int> input{};
   /* ifstream Stream("C:\\Users\\sulta\\OneDrive\\Рабочий стол\\lr_4_4_input.txt", fstream::in | fstream::out | fstream::app);*/
    ifstream Stream("C:\\Users\\SultanGG505_PC\\Desktop\\lr_4_4_input.txt", fstream::in | fstream::out | fstream::app);
    if (Stream.is_open())
    {
        string temp;
        while (!Stream.eof())
        {
            getline(Stream, temp);
            input.push_back(stoi(temp));
        }
        Stream.close();
    }
    else
        cout << "Файл не открыт" << endl;
    
    /// <summary>
    /// здесь использую цикл while для удобства работы с i
    /// задаём temp как итератор натуральных чисел и i как итератор цикла
    /// пока мы не пройдём до конца введённых через файл чисел, рассматриваем два варианта
    /// 1) если  кол-во упорядочиваний для простых множителей натурального числа temp равно числу из ввода(которое тоже яв-ся кол-вом упорядочиваний для простых множителей числа),
    /// то мы выводим это натуральное число temp и увеличиваем итераторы
    /// 2) если же это не так, то мы увеличиваем только натуральное число temp
    /// Удобство способа заключается в том, что мы начинаем итерацию по натуральным числам с нуля, то есть условие задачи о МИНИМАЛЬНОМ числе выполнено.
    /// </summary>
    /// <returns></returns>
    int temp = 0, i = 0;
    while (i < input.size())
    {
        if (permut(factorize(temp)) == input[i])
        {
            cout << temp << endl;
            i++; temp++;
        }            
        else
        {
            temp++;
        }
    }
}
